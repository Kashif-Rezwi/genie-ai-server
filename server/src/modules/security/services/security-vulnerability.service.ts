import { Injectable, Logger } from '@nestjs/common';
import { LoggingService } from '../../monitoring/services/logging.service';

export interface SecurityVulnerability {
  id: string;
  type: 'critical' | 'high' | 'medium' | 'low' | 'info';
  category:
    | 'authentication'
    | 'authorization'
    | 'data_protection'
    | 'network'
    | 'configuration'
    | 'dependencies';
  title: string;
  description: string;
  impact: string;
  recommendation: string;
  cve?: string;
  cvss_score?: number;
  detected_at: number;
  status: 'open' | 'in_progress' | 'resolved' | 'false_positive';
  evidence?: Record<string, any>;
}

export interface SecurityAuditReport {
  id: string;
  timestamp: number;
  overall_score: number;
  vulnerabilities: {
    critical: number;
    high: number;
    medium: number;
    low: number;
    info: number;
    total: number;
  };
  categories: {
    authentication: number;
    authorization: number;
    data_protection: number;
    network: number;
    configuration: number;
    dependencies: number;
  };
  recommendations: string[];
  compliance: {
    owasp_top_10: number;
    pci_dss: number;
    gdpr: number;
  };
}

@Injectable()
export class SecurityVulnerabilityService {
  private readonly logger = new Logger(SecurityVulnerabilityService.name);
  private readonly vulnerabilities: SecurityVulnerability[] = [];
  private readonly auditReports: SecurityAuditReport[] = [];
  private readonly maxVulnerabilities = 1000;
  private readonly maxReports = 100;

  constructor(private readonly loggingService: LoggingService) {}

  /**
   * Add vulnerabilities to storage
   */
  addVulnerabilities(vulnerabilities: SecurityVulnerability[]): void {
    this.vulnerabilities.push(...vulnerabilities);
    this.cleanupOldVulnerabilities();
  }

  /**
   * Add audit report to storage
   */
  addAuditReport(report: SecurityAuditReport): void {
    this.auditReports.push(report);
    this.cleanupOldReports();
  }

  /**
   * Get security vulnerabilities with filtering
   */
  getVulnerabilities(
    type?: string,
    category?: string,
    status?: string,
    limit = 100
  ): SecurityVulnerability[] {
    let filtered = this.vulnerabilities;

    if (type) {
      filtered = filtered.filter(v => v.type === type);
    }
    if (category) {
      filtered = filtered.filter(v => v.category === category);
    }
    if (status) {
      filtered = filtered.filter(v => v.status === status);
    }

    return filtered.slice(-limit);
  }

  /**
   * Get audit reports
   */
  getAuditReports(limit = 10): SecurityAuditReport[] {
    return this.auditReports.slice(-limit);
  }

  /**
   * Get latest audit report
   */
  getLatestAuditReport(): SecurityAuditReport | null {
    return this.auditReports[this.auditReports.length - 1] || null;
  }

  /**
   * Update vulnerability status
   */
  updateVulnerabilityStatus(
    vulnerabilityId: string,
    status: SecurityVulnerability['status']
  ): boolean {
    const vulnerability = this.vulnerabilities.find(v => v.id === vulnerabilityId);
    if (!vulnerability) {
      return false;
    }

    vulnerability.status = status;
    this.loggingService.log(
      `Vulnerability ${vulnerabilityId} status updated to ${status}`,
      'security'
    );
    return true;
  }

  /**
   * Count vulnerabilities by type
   */
  countVulnerabilitiesByType(vulnerabilities: SecurityVulnerability[]): {
    critical: number;
    high: number;
    medium: number;
    low: number;
    info: number;
    total: number;
  } {
    const counts = {
      critical: 0,
      high: 0,
      medium: 0,
      low: 0,
      info: 0,
      total: vulnerabilities.length,
    };

    vulnerabilities.forEach(vuln => {
      counts[vuln.type]++;
    });

    return counts;
  }

  /**
   * Count vulnerabilities by category
   */
  countVulnerabilitiesByCategory(vulnerabilities: SecurityVulnerability[]): {
    authentication: number;
    authorization: number;
    data_protection: number;
    network: number;
    configuration: number;
    dependencies: number;
  } {
    const counts = {
      authentication: 0,
      authorization: 0,
      data_protection: 0,
      network: 0,
      configuration: 0,
      dependencies: 0,
    };

    vulnerabilities.forEach(vuln => {
      counts[vuln.category]++;
    });

    return counts;
  }

  /**
   * Generate unique ID
   */
  generateId(): string {
    return `sec_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  /**
   * Cleanup old vulnerabilities
   */
  private cleanupOldVulnerabilities(): void {
    if (this.vulnerabilities.length > this.maxVulnerabilities) {
      const toRemove = this.vulnerabilities.length - this.maxVulnerabilities;
      this.vulnerabilities.splice(0, toRemove);
      this.logger.log(`Cleaned up ${toRemove} old vulnerabilities`);
    }
  }

  /**
   * Cleanup old reports
   */
  private cleanupOldReports(): void {
    if (this.auditReports.length > this.maxReports) {
      const toRemove = this.auditReports.length - this.maxReports;
      this.auditReports.splice(0, toRemove);
      this.logger.log(`Cleaned up ${toRemove} old audit reports`);
    }
  }
}
